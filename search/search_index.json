{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#blitzly","title":"blitzly \u26a1\ufe0f","text":"<p>Lightning-fast way to get plots with Plotly</p> <p>            </p>"},{"location":"#introduction","title":"Introduction \ud83c\udf89","text":"<p>Plotly is great and powerful. But with great power comes great responsibility \ud83d\udd78. And sometimes you just want to get a plot up and running as fast as possible. That's where blitzly \u26a1\ufe0f comes in. It provides a set of functions that allow you to create plots with Plotly in a lightning-fast way. It's not meant to replace Plotly, but rather to complement it.</p> <p>Check out some examples in the Jupyter notebook. </p>"},{"location":"#install-the-package","title":"Install the package \ud83d\udce6","text":"<p>If you are using pip, you can install the package with the following command: <pre><code>pip install blitzly\n</code></pre></p> <p>If you are using Poetry, you can install the package with the following command: <pre><code>poetry add blitzly\n</code></pre></p>"},{"location":"#installing-dependencies","title":"installing dependencies \ud83e\uddd1\u200d\ud83d\udd27","text":"<p>With pip: <pre><code>pip install -r requirements.txt\n</code></pre></p> <p>With Poetry: <pre><code>poetry install\n</code></pre></p>"},{"location":"#available-plots-so-far","title":"Available plots (so far \ud83d\ude80)","text":"Module Method Description     <code>bar</code> <code>model_feature_importances</code> Creates a bar chart with the feature importance of a model.   <code>bar</code> <code>multi_chart</code> Creates a bar chart with multiple groups.   <code>dumbbell</code> <code>simple_dumbbell</code> Plots a dumbbell plot. This can be used to compare two columns of data to visualize changes.   <code>histogram</code> <code>simple_histogram</code> Plots a histogram with one ore more distributions.   <code>matrix</code> <code>binary_confusion_matrix</code> Plots a confusion matrix for binary classification data.   <code>matrix</code> <code>cramers_v_corr_matrix</code> Cramer's V correlation for categorical features.   <code>matrix</code> <code>pearson_corr_matrix</code> Plots a Pearson product-moment correlation coefficients matrix.   <code>scatter</code> <code>scatter_matrix</code> Plots a scatter matrix.   <code>scatter</code> <code>multi_scatter</code> Create a multi scatter plot. It can be used to visualize the relationship between multiple variables from the same Pandas DataFrame.   <code>scatter</code> <code>dimensionality_reduction</code> Creates a plot to visualize higher dimensionality reduced data using matrix decomposition"},{"location":"#subplots","title":"Subplots \ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66","text":"Module Method Description     <code>subplots</code> <code>make_subplots</code> Create subplots using figure objects created with any of the above available plots."},{"location":"#usage","title":"Usage \ud83e\udd0c","text":"<p>Here are some examples. You can also open the playground notebook \ud83d\udcd2.</p> <p><code>dimensionality_reduction</code>: <pre><code>from blitzly.plots.scatter import dimensionality_reduction\nimport plotly.express as px\n\ndf = px.data.iris()\ndimensionality_reduction(\n  df,\n  n_components=2,\n  target_column=\"species\",\n  reduction_funcs=[\"PCA\", \"TNSE\"],\n)\n</code></pre> Gives you this: </p> <p><code>multi_bar</code>: <pre><code>from blitzly.plots.bar import multi_bar\nimport numpy as np\n\ndata = np.array([[8, 3, 6], [9, 7, 5]])\nerror_array = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\n\nmulti_bar(\n    data,\n    x_labels=[\"Vienna\", \"Berlin\", \"Lisbon\"],\n    group_labels=[\"Personal rating\", \"Global rating\"],\n    errors=error_array,\n    title=\"City ratings \ud83c\udfd9\",\n    mark_x_labels=[\"Lisbon\"],\n    write_html_path=\"see_the_blitz.html\",\n)\n</code></pre> Gives you this: </p> <p><code>scatter matrix</code>: <pre><code>    from blitzly.plots.scatter import scatter_matrix\n    import numpy as np\n    import pandas as pd\n\n    foo = np.random.randn(1000)\n    bar = np.random.randn(1000) + 1\n    blitz = np.random.randint(2, size=1000)\n    licht = np.random.randint(2, size=1000)\n    data = np.array([foo, bar, blitz, licht])\n    df = pd.DataFrame(data.T, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"])\n\n    scatter_matrix(\n        df,\n        dimensions=[\"foo\", \"bar\", \"blitz\"],\n        color_dim=df[\"licht\"],\n        title=\"My first scatter matrix \ud83d\ude43\",\n        show_upper_half=True,\n        diagonal_visible=False,\n        marker_color_scale=\"Rainbow\",\n        marker_line_color=\"blue\",\n        size=(500, 500),\n    )\n</code></pre> Gives you this: </p>"},{"location":"#contributing","title":"Contributing \ud83d\udc69\u200d\ud83d\udcbb","text":"<p>Please check out the guide on how to contribute to this project.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>Thank \ud83d\ude4f you for your interest in contributing to this project! Please read this document to get started.</p>"},{"location":"CONTRIBUTING/#poetry","title":"Poetry","text":"<p>We are using Poetry to manage the dependencies, for deployment, and the virtual environment. If you have not used it before please check out the documentation to get started.</p> <p>If you want to start working on the project. The first thing you have to do is: <pre><code>poetry install --with dev --with test\n</code></pre> This installs all needed dependencies for development and testing.</p>"},{"location":"CONTRIBUTING/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We are using pre-commit to ensure a consistent code style and to avoid common mistakes. Please install the pre-commit and install the hook with: <pre><code>pre-commit install --hook-type commit-msg\n</code></pre></p>"},{"location":"CONTRIBUTING/#homebrew","title":"Homebrew","text":"<p>We are using Homebrew to manage the dependencies for the development environment. Please install Homebrew and run: <pre><code> brew bundle\n</code></pre> to install the dependencies. If you don't want/can't use Homebrew, you can also install the dependencies manually.</p>"},{"location":"CONTRIBUTING/#conventional-commits","title":"Conventional Commits","text":"<p>We are using Conventional Commits to ensure a consistent commit message style. Please use the following commit message format: <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n</code></pre> E.g.: <pre><code>feat: new fantastic plot \ud83d\udcc8\n</code></pre></p>"},{"location":"CONTRIBUTING/#how-to-contribute_1","title":"How to contribute","text":"<p>The following steps will give a short guide on how to contribute to this project:</p> <ul> <li>Create a personal fork of the project on GitHub.</li> <li>Clone the fork on your local machine. Your remote repo on GitHub is called <code>origin</code>.</li> <li>Add the original repository as a remote called <code>upstream</code>.</li> <li>If you created your fork a while ago be sure to pull upstream changes into your local repository.</li> <li>Create a new branch to work on! Start from <code>develop</code> if it exists, else from <code>main</code>.</li> <li>Implement/fix your feature, comment your code, and add some examples.</li> <li>Follow the code style of the project, including indentation. Black, isort, Pylint, mypy, and ssort can help you with it.</li> <li>Run all tests.</li> <li>Write or adapt tests as needed.</li> <li>Add or change the documentation as needed. Please follow the \"Google Python Style Guide\".</li> <li>Squash your commits into a single commit with git's interactive rebase. Create a new branch if necessary.</li> <li>Push your branch to your fork on GitHub, the remote <code>origin</code>.</li> <li>From your fork open a pull request in the correct branch. Target the project's <code>develop</code> branch!</li> <li>Once the pull request is approved and merged you can pull the changes from <code>upstream</code> to your local repo and delete your extra branch(es).</li> </ul>"},{"location":"CONTRIBUTING/#example","title":"Example","text":"Example of a new plot function<pre><code>def simple_dumbbell(\n    data: Union[pd.DataFrame, NDArray],\n    title: str = \"Dumbbell plot\",\n    marker_size: int = 16,\n    marker_line_width: int = 8,\n    plotly_kwargs: Optional[dict] = None,\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: Optional[bool] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n\n    \"\"\"\n    Creates a dumbbell plot. These are useful to show the difference between\n    two sets of data which have the same categories. For instance, it can be\n    used to compare two binary classifiers by plotting the various classification\n    metrics.\n\n    Example:\n    ```python\n    from blitzly.plots.dumbbell import simple_dumbbell\n    import numpy as np\n    import pandas as pd\n\n    data = {\n        \"foo\": np.random.randn(10),\n        \"bar\": np.random.randn(10),\n    }\n    index = [f\"category_{i+1}\" for i in range(10)]\n    df = pd.DataFrame(data, index=index)\n\n    simple_dumbbell(df)\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, NDArray]): Data to plot.\n        title (str): Title of the plot.\n        marker_size (int): Size of the circular marker of the dumbbells.\n        marker_line_width (int): Thickness of the line joining the markers.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments to pass to Plotly `go.Scatter`.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The dumbbell plot.\n    \"\"\"\n\n    data = check_data(data, min_rows=1, min_columns=2, max_columns=2, as_pandas=True)\n\n    fig = go.Figure()\n\n    for index, row in data.iterrows():\n        fig.add_trace(\n            go.Scatter(\n                x=[row.iloc[0], row.iloc[1]],\n                y=[index, index],\n                mode=\"lines\",\n                showlegend=False,\n                line={\n                    \"color\": \"black\",\n                    \"width\": marker_line_width,\n                },\n            )\n        )\n\n    for column_idx, column_name in enumerate(data.columns):\n        fig.add_trace(\n            go.Scatter(\n                x=data.iloc[:, column_idx],\n                y=data.index,\n                mode=\"markers\",\n                name=column_name,\n                **plotly_kwargs if plotly_kwargs else {},\n            )\n        )\n\n    fig.update_traces(\n        marker=dict(size=marker_size),\n    )\n\n    fig = update_figure_layout(fig, title, size, show_legend)\n    return save_show_return(fig, write_html_path, show)\n</code></pre> <p>Let's go through the code step by step: 1. To make blitzly \u26a1\ufe0f simple to use try to provide as many default arguments as possible. Also don't forget to add type hints:</p> Yea! \ud83e\udd73<pre><code>title: str = \"Dumbbell plot\"\n</code></pre> Nay! \ud83d\ude22<pre><code>title\n</code></pre> <ol> <li> <p>Every function in blitzly \u26a1\ufe0f requires the following arguments: <pre><code>plotly_kwargs: Optional[dict] = None,\nshow: bool = True,\nwrite_html_path: Optional[str] = None\n</code></pre> More about this in the next steps.</p> </li> <li> <p>Each function should return <code>BaseFigure</code>. This gives the user the possibility to use the returned Plotly figure in every possible way.</p> </li> <li> <p>The function should have a docstring. The docstring should follow the Google Python Style Guide. The docstring should contain a short description of the function, a short example, a list of all arguments, and a description of the return value.</p> </li> <li> <p><code>check_data</code> is used for validating and preparing the data for the plot. Please don't forget to add it to your implementation.</p> </li> <li> <p>So no code is repeated we use <code>update_figure_layout</code> to update the layout of the figure.</p> </li> <li> <p><code>save_show_return</code> is used to save the figure as an HTML file - if needed, shows the figure, and returns the figure. The use of this function is also mandatory.</p> </li> <li> <p>When you work on the implementation try to make the implementation as generic as possible. In other words, try to wrap a powerful Plotly implementation in your blitzly function and pass as many arguments as possible to the user while giving default arguments. In addition to this please also provide a <code>plotly_kwargs</code> argument which allows the user to pass additional keyword arguments to the Plotly function. This way the user can customize the plot as much as possible.</p> </li> <li> <p>Don't forget to write some meaningful unit tests. The tests should cover all possible use cases of the function and should be located in the <code>tests/test_cases</code> folder and should be named <code>test_&lt;function_name_with_use_case&gt;.py</code>.</p> </li> <li> <p>Documentation: Please add your new blitly \u26a1\ufe0f plot to the list in the <code>README.md</code> file. If you think your plot implementation is worth to be documented even more, feel free to add it together with a short description to the end of the <code>playground.ipynb</code> notebook.</p> </li> </ol>  <p>Get in touch</p> <p>That's it! \ud83c\udf89 Happy ploding (plotting + coding)! \ud83d\udcca\ud83d\udc69\u200d\ud83d\udcbb If you have any questions feel free to contact us!</p>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#blitzly.etc.utils.check_data","title":"<code>check_data(data, only_numerical_values=True, only_square_matrix=False, min_rows=None, max_rows=None, min_columns=None, max_columns=None, as_pandas=False)</code>","text":"<p>Checks if the data is valid for plotting. The function checks for:</p> <ul> <li> <p>The data is a DataFrame or numpy array of values.</p> </li> <li> <p>If the data is a numpy array, it must be 1- or 2-dimensional.</p> </li> <li> <p>(Optional) if the data is numerical.</p> </li> <li> <p>(Optional) if data is a square matrix.</p> </li> <li> <p>(Optional) If the data is a numpy array, it must have at least <code>min_rows</code> rows.</p> </li> <li> <p>(Optional) If the data is a numpy array, it must have at most <code>max_rows</code> rows.</p> </li> <li> <p>(Optional) If the data is a numpy array, it must have at least <code>min_columns</code> columns.</p> </li> <li> <p>(Optional) If the data is a numpy array, it must have at most <code>max_columns</code> columns.</p> </li> </ul> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, pd.Series, NDArray]</code>  <p>The data which should be plotted. Either one or multiple columns of data.</p>  required    <code>only_numerical_values</code>  <code>Optional[bool]</code>  <p>Whether to fail if the data is not numerical.</p>  <code>True</code>    <code>only_square_matrix</code>  <code>Optional[bool]</code>  <p>Whether to fail the data is not a square matrix.</p>  <code>False</code>    <code>min_rows</code>  <code>Optional[int]</code>  <p>The minimum number of rows the data must have.</p>  <code>None</code>    <code>max_rows</code>  <code>Optional[int]</code>  <p>The maximum number of rows the data must have.</p>  <code>None</code>    <code>min_columns</code>  <code>Optional[int]</code>  <p>The minimum number of columns the data must have.</p>  <code>None</code>    <code>max_columns</code>  <code>Optional[int]</code>  <p>The maximum number of columns the data must have.</p>  <code>None</code>    <code>as_pandas</code>  <code>bool</code>  <p>Whether to keep data as or convert data to pd.DataFrame</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>Union[NDArray[Any], pd.DataFrame, pd.Series]</code>  <p>Union[pd.DataFrame, NDArray]: The data that passes all checks, and is converted to the required dtype.</p>    <p>Raises:</p>    Type Description      <code>TypeError</code>  <p>If the data is not a DataFrame, numpy array, or list of values.</p>    <code>TypeError</code>  <p>If the data is a numpy array with a non-numerical <code>dtype</code>.</p>    <code>ValueError</code>  <p>If the data is a numpy array is not a square matrix.</p>    <code>ValueError</code>  <p>If the data is a numpy array with more than 2 dimensions.</p>     Source code in <code>blitzly/etc/utils.py</code> <pre><code>def check_data(\n    data: Union[pd.DataFrame, pd.Series, NDArray],\n    only_numerical_values: bool = True,\n    only_square_matrix: bool = False,\n    min_rows: Optional[int] = None,\n    max_rows: Optional[int] = None,\n    min_columns: Optional[int] = None,\n    max_columns: Optional[int] = None,\n    as_pandas: bool = False,\n) -&gt; Union[NDArray[Any], pd.DataFrame, pd.Series]:\n    \"\"\"Checks if the data is valid for plotting. The function checks for:\n\n    - The data is a DataFrame or numpy array of values.\n\n    - If the data is a numpy array, it must be 1- or 2-dimensional.\n\n    - *(Optional)* if the data is numerical.\n\n    - *(Optional)* if data is a square matrix.\n\n    - *(Optional)* If the data is a numpy array, it must have at least `min_rows` rows.\n\n    - *(Optional)* If the data is a numpy array, it must have at most `max_rows` rows.\n\n    - *(Optional)* If the data is a numpy array, it must have at least `min_columns` columns.\n\n    - *(Optional)* If the data is a numpy array, it must have at most `max_columns` columns.\n\n    Args:\n        data (Union[pd.DataFrame, pd.Series, NDArray]): The data which should be plotted.\n            Either one or multiple columns of data.\n        only_numerical_values (Optional[bool]): Whether to fail if the data is not numerical.\n        only_square_matrix (Optional[bool]): Whether to fail the data is not a square matrix.\n        min_rows (Optional[int]): The minimum number of rows the data must have.\n        max_rows (Optional[int]): The maximum number of rows the data must have.\n        min_columns (Optional[int]): The minimum number of columns the data must have.\n        max_columns (Optional[int]): The maximum number of columns the data must have.\n        as_pandas (bool): Whether to keep data as or convert data to pd.DataFrame\n\n    Returns:\n        Union[pd.DataFrame, NDArray]: The data that passes all checks, and is converted to the required dtype.\n\n    Raises:\n        TypeError: If the data is not a DataFrame, numpy array, or list of values.\n        TypeError: If the data is a numpy array with a non-numerical `dtype`.\n        ValueError: If the data is a numpy array is not a square matrix.\n        ValueError: If the data is a numpy array with more than 2 dimensions.\n    \"\"\"\n\n    if isinstance(data, (pd.DataFrame, pd.Series, np.ndarray)) is False:\n        raise TypeError(\n            f\"\"\"\n            Invalid data type! Type `{data.__class__.__name__}` is not supported.\n            Please choose between a DataFrame, numpy array, or list of values.\n        \"\"\"\n        )\n\n    if isinstance(data, np.ndarray) and as_pandas:\n        df = pd.DataFrame(data)\n\n    if isinstance(data, (pd.DataFrame, pd.Series)):\n        df = data.copy()\n        data = data.to_numpy()\n\n    if only_numerical_values and data.dtype not in [\n        np.int8,\n        np.int16,\n        np.int32,\n        np.int64,\n        np.float16,\n        np.float32,\n        np.float64,\n    ]:\n        raise TypeError(\"Data must be numerical (`np.number`)!\")\n\n    if only_square_matrix and data.shape[0] != data.shape[1]:\n        raise ValueError(\n            f\"Data must be a square matrix! But it's shape is: `{data.shape}`.\"\n        )\n\n    if data.ndim &gt; 2:\n        raise ValueError(\"NumPy array must be 1- or 2-dimensional!\")\n\n    if min_rows and data.shape[0] &lt; min_rows:\n        raise ValueError(f\"The data must have at least {min_rows} row(s)!\")\n\n    if max_rows and data.shape[0] &gt; max_rows:\n        raise ValueError(f\"The data must have a maximum of {max_rows} row(s)!\")\n\n    if min_columns and data.shape[1] &lt; min_columns:\n        raise ValueError(f\"The data must have at least {min_columns} column(s)!\")\n\n    if max_columns and data.shape[1] &gt; max_columns:\n        raise ValueError(f\"The data must have a maximum of {max_columns} column(s)!\")\n\n    if \"df\" in locals() and as_pandas:\n        return df\n\n    return data.copy()\n</code></pre>"},{"location":"utils/#blitzly.etc.utils.save_show_return","title":"<code>save_show_return(fig, write_html_path=None, show=True)</code>","text":"<p>Saves the figure if needed, shows the figure if needed, and returns a it.</p> <p>Parameters:</p>    Name Type Description Default     <code>fig</code>  <code>BaseFigure</code>  <p>The Plotly figure.</p>  required    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The Plotly figure.</p>     Source code in <code>blitzly/etc/utils.py</code> <pre><code>def save_show_return(\n    fig: BaseFigure, write_html_path: Optional[str] = None, show: bool = True\n) -&gt; BaseFigure:\n    \"\"\"Saves the figure if needed, shows the figure if needed, and returns a\n    it.\n\n    Args:\n        fig (BaseFigure): The Plotly figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n        show (bool): Whether to show the figure.\n\n    Returns:\n        BaseFigure: The Plotly figure.\n    \"\"\"\n\n    if write_html_path:\n        fig.write_html(write_html_path)\n    if show:\n        fig.show()\n    return fig\n</code></pre>"},{"location":"utils/#blitzly.etc.utils.update_figure_layout","title":"<code>update_figure_layout(fig, title=None, size=None, show_legend=None, show_scale=None)</code>","text":"<p>Updates the figure by setting the title and also scales the plot to the given size.</p> <p>Parameters:</p>    Name Type Description Default     <code>fig</code>  <code>BaseFigure</code>  <p>The Plotly figure.</p>  required    <code>title</code>  <code>Optional[str]</code>  <p>Title of the plot.</p>  <code>None</code>    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>None</code>    <code>show_scale</code>  <code>Optional[bool]</code>  <p>Whether to show the scale.</p>  <code>None</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The Plotly figure.</p>     Source code in <code>blitzly/etc/utils.py</code> <pre><code>def update_figure_layout(\n    fig: BaseFigure,\n    title: Optional[str] = None,\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: Optional[bool] = None,\n    show_scale: Optional[bool] = None,\n) -&gt; BaseFigure:\n    \"\"\"Updates the figure by setting the title and also scales the plot to the\n    given size.\n\n    Args:\n        fig (BaseFigure): The Plotly figure.\n        title (Optional[str]): Title of the plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show_scale (Optional[bool]): Whether to show the scale.\n        size (Optional[Tuple[int, int]): Size of the plot.\n\n    Returns:\n        BaseFigure: The Plotly figure.\n    \"\"\"\n\n    if title:\n        fig.update_layout(\n            title_text=f\"&lt;i&gt;&lt;b&gt;{title}&lt;/b&gt;&lt;/i&gt;\",\n        )\n\n    if show_legend is not None:\n        fig.update_layout(showlegend=show_legend)\n\n    if show_scale is not None:\n        fig[\"data\"][0][\"showscale\"] = show_scale\n\n    if size:\n        fig.update_layout(\n            width=size[0],\n            height=size[1],\n        )\n    return fig\n</code></pre>"},{"location":"plots/bar/","title":"Bar","text":""},{"location":"plots/bar/#blitzly.plots.bar.model_feature_importances","title":"<code>model_feature_importances(X_test, model, title='Feature importance', horizontal=True, size=None, show=True, write_html_path=None)</code>","text":"<p>Creates a bar chart with the feature importance of a model.</p> <p>Example: ```python from blitzly.plots.bar import model_feature_importance import pandas as pd from sklearn.ensemble import RandomForestClassifier from sklearn.datasets import make_classification from sklearn.model_selection import train_test_split</p> <p>X, y = make_classification(     n_samples=100,     n_features=4,     n_informative=2,     n_redundant=0,     random_state=42,     shuffle=False, )</p> <p>X = pd.DataFrame(X, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"]) y = pd.Series(y)</p> <p>X_train, X_test, y_train, _ = train_test_split(X, y)</p> <p>model = RandomForestClassifier() model.fit(X_train, y_train)</p> <p>model_feature_importances(X_test, model)</p> <p>Args:     X_test (pd.DataFrame): The test data for the model. You can also use the <code>train</code> data but it is recommend to use <code>test</code>.     model (Any): The model to get the feature importance from. The model must have a <code>feature_importances_</code> attribute!     title (Optional[str]): The title of the plot. Defaults to \"Feature importance\".     horizontal (bool): Whether to plot the bar chart horizontally or vertically.     size (Optional[Tuple[int, int]]): The size of the plot.     show (bool): Whether to show the plot.     write_html_path (Optional[str]): The path to write the plot as HTML.</p> <p>Raises:     AttributeError: If the model does not have a <code>feature_importances_</code> attribute.</p> <p>Returns:     BaseFigure: The plotly figure.</p>  Source code in <code>blitzly/plots/bar.py</code> <pre><code>def model_feature_importances(\n    X_test: pd.DataFrame,\n    model: Any,\n    title: str = \"Feature importance\",\n    horizontal: bool = True,\n    size: Optional[Tuple[int, int]] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Creates a bar chart with the feature importance of a model.\n\n    Example:\n    ```python\n    from blitzly.plots.bar import model_feature_importance\n    import pandas as pd\n    from sklearn.ensemble import RandomForestClassifier\n    from sklearn.datasets import make_classification\n    from sklearn.model_selection import train_test_split\n\n    X, y = make_classification(\n        n_samples=100,\n        n_features=4,\n        n_informative=2,\n        n_redundant=0,\n        random_state=42,\n        shuffle=False,\n    )\n\n    X = pd.DataFrame(X, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"])\n    y = pd.Series(y)\n\n    X_train, X_test, y_train, _ = train_test_split(X, y)\n\n    model = RandomForestClassifier()\n    model.fit(X_train, y_train)\n\n    model_feature_importances(X_test, model)\n\n    Args:\n        X_test (pd.DataFrame): The test data for the model. You can also use the `train` data but it is recommend to use `test`.\n        model (Any): The model to get the feature importance from. The model must have a `feature_importances_` attribute!\n        title (Optional[str]): The title of the plot. Defaults to \"Feature importance\".\n        horizontal (bool): Whether to plot the bar chart horizontally or vertically.\n        size (Optional[Tuple[int, int]]): The size of the plot.\n        show (bool): Whether to show the plot.\n        write_html_path (Optional[str]): The path to write the plot as HTML.\n\n    Raises:\n        AttributeError: If the model does not have a `feature_importances_` attribute.\n\n    Returns:\n        BaseFigure: The plotly figure.\n    \"\"\"\n\n    if hasattr(model, \"feature_importances_\"):\n        df = pd.DataFrame(\n            {\"feature\": X_test.columns, \"importance\": model.feature_importances_}\n        ).sort_values(\"importance\", ascending=True)\n    else:\n        raise AttributeError(\n            \"The model does not have a `feature_importances_` attribute!\"\n        )\n\n    if horizontal:\n        fig = px.bar(df, x=\"importance\", y=\"feature\")\n    else:\n        fig = px.bar(df, x=\"feature\", y=\"importance\")\n\n    fig = update_figure_layout(fig, title, size)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/bar/#blitzly.plots.bar.multi_bar","title":"<code>multi_bar(data, group_labels, x_labels, mark_x_labels=None, mark_x_label_color='crimson', title='Bar chart', stack=False, text_position='none', hover_texts=None, errors=None, size=None, show_legend=True, show=True, write_html_path=None)</code>","text":"<p>Creates a bar chart with multiple groups. Each group is represented by a bar. The bars are grouped by the x-axis. The number of <code>group_labels</code> must be equal to the number of rows in the data. The number of <code>x_labels</code> must be equal to the number of columns in the data.</p> <p>Example: <pre><code>from blitzly.plots.bar import multi_bar\nimport numpy as np\n\ndata=np.array([[1, 2, 3], [4, 5, 6]])\nerrors=np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),\n\nmulti_bar(\n    data,\n    x_labels=[\"X1\", \"X2\", \"X3\"],\n    group_labels=[\"Z1\", \"Z2\"],\n    hover_texts=[\"foo\", \"bar\", \"blitzly\"],\n    errors=errors\n)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, pd.Series, NDArray]</code>  <p>The data to plot.</p>  required    <code>group_labels</code>  <code>List[str]</code>  <p>The labels for the groups.</p>  required    <code>x_labels</code>  <code>List[str]</code>  <p>The labels for the x-axis.</p>  required    <code>mark_x_labels</code>  <code>Optional[List[str]]</code>  <p>The bars of <code>x_label</code> which should be marked.</p>  <code>None</code>    <code>mark_x_label_color</code>  <code>str</code>  <p>The color of the marked bars.</p>  <code>'crimson'</code>    <code>title</code>  <code>Optional[str]</code>  <p>The title of the bar chart.</p>  <code>'Bar chart'</code>    <code>stack</code>  <code>Optional[bool]</code>  <p>Whether to stack the bars. Values are summed up by columns. By default, the bars are grouped. Stacked bars don't support errors. If provided, they will be ignored.</p>  <code>False</code>    <code>text_position</code>  <code>Optional[str]</code>  <p>The position of the text. Can be \"auto\", \"inside\", \"outside\", \"none\".</p>  <code>'none'</code>    <code>hover_texts</code>  <code>Optional[List[str]]</code>  <p>The hover texts for the data.</p>  <code>None</code>    <code>errors</code>  <code>Optional[Union[pd.DataFrame, pd.Series, NDArray]]</code>  <p>The errors for the data.</p>  <code>None</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>True</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The figure.</p>     Source code in <code>blitzly/plots/bar.py</code> <pre><code>def multi_bar(\n    data: Union[pd.DataFrame, pd.Series, NDArray],\n    group_labels: List[str],\n    x_labels: List[str],\n    mark_x_labels: Optional[List[str]] = None,\n    mark_x_label_color: str = \"crimson\",\n    title: str = \"Bar chart\",\n    stack: bool = False,\n    text_position: str = \"none\",\n    hover_texts: Optional[List[str]] = None,\n    errors: Optional[Union[pd.DataFrame, pd.Series, NDArray]] = None,\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: bool = True,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Creates a bar chart with multiple groups. Each group is represented by a\n    bar. The bars are grouped by the x-axis. The number of `group_labels` must\n    be equal to the number of rows in the data. The number of `x_labels` must\n    be equal to the number of columns in the data.\n\n    Example:\n    ```python\n    from blitzly.plots.bar import multi_bar\n    import numpy as np\n\n    data=np.array([[1, 2, 3], [4, 5, 6]])\n    errors=np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),\n\n    multi_bar(\n        data,\n        x_labels=[\"X1\", \"X2\", \"X3\"],\n        group_labels=[\"Z1\", \"Z2\"],\n        hover_texts=[\"foo\", \"bar\", \"blitzly\"],\n        errors=errors\n    )\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, pd.Series, NDArray]): The data to plot.\n        group_labels (List[str]): The labels for the groups.\n        x_labels (List[str]): The labels for the x-axis.\n        mark_x_labels (Optional[List[str]]): The bars of `x_label` which should be marked.\n        mark_x_label_color (str): The color of the marked bars.\n        title (Optional[str]): The title of the bar chart.\n        stack (Optional[bool]): Whether to stack the bars. Values are summed up by columns.\n            By default, the bars are grouped. Stacked bars don't support errors. If provided, they will be ignored.\n        text_position (Optional[str]): The position of the text. Can be \"auto\", \"inside\", \"outside\", \"none\".\n        hover_texts (Optional[List[str]]): The hover texts for the data.\n        errors (Optional[Union[pd.DataFrame, pd.Series, NDArray]]): The errors for the data.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The figure.\n    \"\"\"\n\n    data = check_data(data)\n\n    if isinstance(errors, np.ndarray):\n        errors = check_data(errors)\n\n    _check_data_ready_for_bar(data, group_labels, x_labels, hover_texts, errors)\n\n    colors = None\n    if mark_x_labels:\n        colors = [\n            \"lightslategray\",\n        ] * len(x_labels)\n        for mark in mark_x_labels:\n            colors[x_labels.index(mark)] = mark_x_label_color\n\n    fig = go.Figure()\n    for idx, dt in enumerate(data):\n        error_dict = None\n        if isinstance(errors, np.ndarray) and stack is False:\n            error = errors[idx,]\n            error_dict = dict(type=\"data\", array=error, visible=True)\n        fig.add_trace(\n            go.Bar(\n                name=group_labels[idx],\n                x=x_labels,\n                y=dt,\n                error_y=error_dict,\n                hovertext=hover_texts,\n                text=dt,\n                textposition=text_position,\n                marker_color=colors,\n            )\n        )\n\n    fig.update_layout(barmode=\"stack\" if stack else \"group\", xaxis_tickangle=-45)\n\n    fig = update_figure_layout(\n        fig, title, size, (show_legend and mark_x_labels is None)\n    )\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/dumbbell/","title":"Dumbbell","text":""},{"location":"plots/dumbbell/#blitzly.plots.dumbbell.simple_dumbbell","title":"<code>simple_dumbbell(data, title='Dumbbell plot', marker_size=16, marker_line_width=8, plotly_kwargs=None, size=None, show_legend=None, show=True, write_html_path=None)</code>","text":"<p>Creates a dumbbell plot. These are useful to show the difference between two sets of data which have the same categories. For instance, it can be used to compare two binary classifiers by plotting the various classification metrics.</p> <p>Example: <pre><code>from blitzly.plots.dumbbell import simple_dumbbell\nimport numpy as np\nimport pandas as pd\n\ndata = {\n    \"foo\": np.random.randn(10),\n    \"bar\": np.random.randn(10),\n}\nindex = [f\"category_{i+1}\" for i in range(10)]\ndf = pd.DataFrame(data, index=index)\n\nsimple_dumbbell(df)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, NDArray]</code>  <p>Data to plot.</p>  required    <code>title</code>  <code>str</code>  <p>Title of the plot.</p>  <code>'Dumbbell plot'</code>    <code>marker_size</code>  <code>int</code>  <p>Size of the circular marker of the dumbbells.</p>  <code>16</code>    <code>marker_line_width</code>  <code>int</code>  <p>Thickness of the line joining the markers.</p>  <code>8</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments to pass to Plotly <code>go.Scatter</code>.</p>  <code>None</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The dumbbell plot.</p>     Source code in <code>blitzly/plots/dumbbell.py</code> <pre><code>def simple_dumbbell(\n    data: Union[pd.DataFrame, NDArray],\n    title: str = \"Dumbbell plot\",\n    marker_size: int = 16,\n    marker_line_width: int = 8,\n    plotly_kwargs: Optional[dict] = None,\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: Optional[bool] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Creates a dumbbell plot. These are useful to show the difference between\n    two sets of data which have the same categories. For instance, it can be\n    used to compare two binary classifiers by plotting the various\n    classification metrics.\n\n    Example:\n    ```python\n    from blitzly.plots.dumbbell import simple_dumbbell\n    import numpy as np\n    import pandas as pd\n\n    data = {\n        \"foo\": np.random.randn(10),\n        \"bar\": np.random.randn(10),\n    }\n    index = [f\"category_{i+1}\" for i in range(10)]\n    df = pd.DataFrame(data, index=index)\n\n    simple_dumbbell(df)\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, NDArray]): Data to plot.\n        title (str): Title of the plot.\n        marker_size (int): Size of the circular marker of the dumbbells.\n        marker_line_width (int): Thickness of the line joining the markers.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments to pass to Plotly `go.Scatter`.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The dumbbell plot.\n    \"\"\"\n\n    data = check_data(data, min_rows=1, min_columns=2, max_columns=2, as_pandas=True)\n\n    fig = go.Figure()\n\n    for index, row in data.iterrows():\n        fig.add_trace(\n            go.Scatter(\n                x=[row.iloc[0], row.iloc[1]],\n                y=[index, index],\n                mode=\"lines\",\n                showlegend=False,\n                line={\n                    \"color\": \"black\",\n                    \"width\": marker_line_width,\n                },\n            )\n        )\n\n    for column_idx, column_name in enumerate(data.columns):\n        fig.add_trace(\n            go.Scatter(\n                x=data.iloc[:, column_idx],\n                y=data.index,\n                mode=\"markers\",\n                name=column_name,\n                **plotly_kwargs if plotly_kwargs else {},\n            )\n        )\n\n    fig.update_traces(\n        marker=dict(size=marker_size),\n    )\n\n    fig = update_figure_layout(fig, title, size, show_legend)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/histogram/","title":"Histogram","text":""},{"location":"plots/histogram/#blitzly.plots.histogram.simple_histogram","title":"<code>simple_histogram(data, show_legend=True, opacity=0.75, title='Histogram', x_label='x', y_label='y', size=None, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Create a simple histogram from a pandas DataFrame, numpy array, or list of values.</p> <p>Example: <pre><code>import numpy as np\nfrom blitzly.plots.histogram import simple_histogram\n\nfoo = np.random.randn(500)\nbar = np.random.randn(500) + 1\ndata = np.array([foo, bar])\n\nsimple_histogram(\n    data,\n    title=\"Histogram of foo and bar\",\n    x_label=\"Value\",\n    y_label=\"Count\",\n    write_html_path=\"the_blitz.html\"\n)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, pd.Series, NDArray]</code>  <p>The data which should be plotted. Either one or multiple columns of data.</p>  required    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>True</code>    <code>opacity</code>  <code>Optional[float]</code>  <p>The opacity of the histogram.</p>  <code>0.75</code>    <code>title</code>  <code>Optional[str]</code>  <p>The title of the histogram.</p>  <code>'Histogram'</code>    <code>x_label</code>  <code>Optional[str]</code>  <p>The label of the x-axis.</p>  <code>'x'</code>    <code>y_label</code>  <code>Optional[str]</code>  <p>The label of the y-axis.</p>  <code>'y'</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments to pass to Plotly <code>Histogram</code>.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>      Source code in <code>blitzly/plots/histogram.py</code> <pre><code>def simple_histogram(\n    data: Union[pd.DataFrame, pd.Series, NDArray],\n    show_legend: bool = True,\n    opacity: float = 0.75,\n    title: str = \"Histogram\",\n    x_label: str = \"x\",\n    y_label: str = \"y\",\n    size: Optional[Tuple[int, int]] = None,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Create a simple histogram from a pandas DataFrame, numpy array, or list\n    of values.\n\n    Example:\n    ```python\n    import numpy as np\n    from blitzly.plots.histogram import simple_histogram\n\n    foo = np.random.randn(500)\n    bar = np.random.randn(500) + 1\n    data = np.array([foo, bar])\n\n    simple_histogram(\n        data,\n        title=\"Histogram of foo and bar\",\n        x_label=\"Value\",\n        y_label=\"Count\",\n        write_html_path=\"the_blitz.html\"\n    )\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, pd.Series, NDArray]): The data which should be plotted.\n            Either one or multiple columns of data.\n        show_legend (Optional[bool]): Whether to show the legend.\n        opacity (Optional[float]): The opacity of the histogram.\n        title (Optional[str]): The title of the histogram.\n        x_label (Optional[str]): The label of the x-axis.\n        y_label (Optional[str]): The label of the y-axis.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments to pass to Plotly `Histogram`.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n    \"\"\"\n\n    data = check_data(data)\n\n    if data.ndim == 1:\n        data = [data]\n    else:\n        data = data.T\n\n    fig = go.Figure()\n    for d in data:\n        fig.add_trace(go.Histogram(x=d, **plotly_kwargs if plotly_kwargs else {}))\n\n    fig.update_layout(barmode=\"overlay\")\n    fig.update_xaxes(title_text=x_label)\n    fig.update_yaxes(title_text=y_label)\n    fig.update_traces(opacity=opacity)\n\n    fig = update_figure_layout(fig, title, size, show_legend)\n\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/matrix/","title":"Matrix","text":""},{"location":"plots/matrix/#blitzly.plots.matrix.binary_confusion_matrix","title":"<code>binary_confusion_matrix(data, positive_class_label='positive class', negative_class_label='negative class', title='Confusion matrix', normalize=None, show_scale=False, color_scale='Plasma', size=None, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Creates a confusion matrix for binary classification.</p> <p>Example: <pre><code>from blitzly.plots.matrix import binary_confusion_matrix\nimport numpy as np\n\ndata = np.array([[1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 1]])\nbinary_confusion_matrix(data, write_html_path=\"the_blitz.html\")\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, NDArray]</code>  <p>The data which should be plotted.</p>  required    <code>positive_class_label</code>  <code>Optional[str]</code>  <p>The label of the positive class.</p>  <code>'positive class'</code>    <code>negative_class_label</code>  <code>Optional[str]</code>  <p>The label of the negative class.</p>  <code>'negative class'</code>    <code>title</code>  <code>Optional[str]</code>  <p>The title of the confusion matrix.</p>  <code>'Confusion matrix'</code>    <code>normalize</code>  <code>Optional[str]</code>  <p>Normalizes confusion matrix over the true (rows), predicted (columns) conditions or all the population. If None, confusion matrix will not be normalized.</p>  <code>None</code>    <code>show_scale</code>  <code>Optional[bool]</code>  <p>Whether to show the color scale.</p>  <code>False</code>    <code>color_scale</code>  <code>Optional[str]</code>  <p>The color scale of the confusion matrix.</p>  <code>'Plasma'</code>    <code>size</code>  <code>Optional[Tuple[int, int]]</code>  <p>The size of the plot.</p>  <code>None</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments for Plotly.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The confusion matrix.</p>     Source code in <code>blitzly/plots/matrix.py</code> <pre><code>def binary_confusion_matrix(\n    data: Union[pd.DataFrame, NDArray],\n    positive_class_label: str = \"positive class\",\n    negative_class_label: str = \"negative class\",\n    title: str = \"Confusion matrix\",\n    normalize: Optional[str] = None,\n    show_scale: bool = False,\n    color_scale: str = \"Plasma\",\n    size: Optional[Tuple[int, int]] = None,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Creates a confusion matrix for binary classification.\n\n    Example:\n    ```python\n    from blitzly.plots.matrix import binary_confusion_matrix\n    import numpy as np\n\n    data = np.array([[1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 1]])\n    binary_confusion_matrix(data, write_html_path=\"the_blitz.html\")\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, NDArray]): The data which should be plotted.\n        positive_class_label (Optional[str]): The label of the positive class.\n        negative_class_label (Optional[str]): The label of the negative class.\n        title (Optional[str]): The title of the confusion matrix.\n        normalize (Optional[str]): Normalizes confusion matrix over the true (rows), predicted (columns) conditions or all the population.\n            If None, confusion matrix will not be normalized.\n        show_scale (Optional[bool]): Whether to show the color scale.\n        color_scale (Optional[str]): The color scale of the confusion matrix.\n        size (Optional[Tuple[int, int]]): The size of the plot.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments for Plotly.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The confusion matrix.\n    \"\"\"\n\n    check_data(data, min_columns=2, max_rows=2)\n\n    X = sk_confusion_matrix(\n        data[0], data[1], normalize=normalize\n    )  # [[tn, fp],[fn, tp]]\n\n    classes = [negative_class_label, positive_class_label]\n    fig = ff.create_annotated_heatmap(\n        X,\n        x=classes,\n        y=classes,\n        annotation_text=[[str(y) for y in x] for x in X],\n        colorscale=color_scale,\n        hovertext=[\n            [\"True negative\", \"False positive\"],\n            [\"False negative\", \"True positive\"],\n        ],\n        **(plotly_kwargs or {}),\n    )\n\n    fig.update_layout(\n        xaxis=dict(title=\"Predicted value\"),\n        yaxis=dict(title=\"Real value\"),\n    )\n\n    fig.update_layout(margin=dict(t=100, l=180))\n    fig[\"data\"][0][\"showscale\"] = show_scale\n\n    fig = update_figure_layout(fig, title, size)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/matrix/#blitzly.plots.matrix.cramers_v_corr_matrix","title":"<code>cramers_v_corr_matrix(data, title=\"Cramer's V correlation matrix\", show_scale=False, size=(700, 700), decimal_places=3, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Cramer's V correlation matrix. It can be used to get the correlations between nominal variables.</p> <p>Example: <pre><code>from blitzly.matrix import cramers_v_corr_matrix\nimport pandas as pd\n\ndf = pd.DataFrame(\n    {\n        \"foo\": [\"1\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n        \"bar\": [\"3\", \"2\", \"3\", \"7\", \"5\", \"7\"],\n        \"blitzly\": [\"9\", \"3\", \"4\", \"6\", \"7\", \"9\"],\n        \"licht\": [\"1\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n    }\n)\n\nfig = cramers_v_corr_matrix(df)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>pd.DataFrame</code>  <p>The data which should be plotted. All columns need to be nominal/categorical.</p>  required    <code>title</code>  <code>Optional[str]</code>  <p>The title of the correlation matrix.</p>  <code>\"Cramer's V correlation matrix\"</code>    <code>show_scale</code>  <code>Optional[bool]</code>  <p>Whether to show the color scale.</p>  <code>False</code>    <code>decimal_places</code>  <code>Optional[int]</code>  <p>The number of decimal places to round the values to. This only applies to the values shown on the plot.</p>  <code>3</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>(700, 700)</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments for Plotly.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The figure.</p>     Source code in <code>blitzly/plots/matrix.py</code> <pre><code>def cramers_v_corr_matrix(\n    data: pd.DataFrame,\n    title: str = \"Cramer's V correlation matrix\",\n    show_scale: bool = False,\n    size: Tuple[int, int] = (700, 700),\n    decimal_places: int = 3,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"[Cramer's V correlation](https://www.wikiwand.com/en/Cram%C3%A9r%27s_V)\n    matrix. It can be used to get the correlations between nominal variables.\n\n    Example:\n    ```python\n    from blitzly.matrix import cramers_v_corr_matrix\n    import pandas as pd\n\n    df = pd.DataFrame(\n        {\n            \"foo\": [\"1\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n            \"bar\": [\"3\", \"2\", \"3\", \"7\", \"5\", \"7\"],\n            \"blitzly\": [\"9\", \"3\", \"4\", \"6\", \"7\", \"9\"],\n            \"licht\": [\"1\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n        }\n    )\n\n    fig = cramers_v_corr_matrix(df)\n    ```\n\n    Args:\n        data (pd.DataFrame): The data which should be plotted. All columns need to be nominal/categorical.\n        title (Optional[str]): The title of the correlation matrix.\n        show_scale (Optional[bool]): Whether to show the color scale.\n        decimal_places (Optional[int]): The number of decimal places to round the values to. This only applies to the values shown on the plot.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments for Plotly.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n\n    Returns:\n        BaseFigure: The figure.\n    \"\"\"\n\n    data = check_data(\n        data, min_columns=2, min_rows=2, as_pandas=True, only_numerical_values=False\n    )\n\n    if all(x == np.object_ for x in list(data.dtypes)) is False:\n        warnings.warn(\n            \"\"\"All columns should be from type `object` since the encoding is done internally.\n        But don't worry. It should work anyway.\"\"\"\n        )\n\n    d: Dict[str, List[Union[str, float]]] = {\n        \"Feature1\": [],\n        \"Feature2\": [],\n        \"Correlation\": [],\n    }\n    data = pd.DataFrame(OrdinalEncoder().fit_transform(data) + 1, columns=data.columns)\n\n    for _, x in enumerate(itertools.combinations(data.columns, r=2)):\n        temp_data = np.array(pd.crosstab(data[x[0]], data[x[1]]))\n\n        chi2 = stats.chi2_contingency(temp_data, correction=False)[0]\n        n = np.sum(temp_data)\n        minimum_dimension = min(temp_data.shape) - 1\n        res = np.sqrt((chi2 / n) / minimum_dimension)\n\n        d[\"Feature1\"].append(x[0])\n        d[\"Feature2\"].append(x[1])\n        d[\"Correlation\"].append(res)\n\n    df = pd.DataFrame(d)\n\n    fig = go.Figure(\n        data=go.Heatmap(\n            z=df[\"Correlation\"],\n            text=np.round(df[\"Correlation\"], decimals=decimal_places),\n            texttemplate=\"%{text}\",\n            x=d[\"Feature1\"],\n            y=d[\"Feature2\"],\n        ),\n        **(plotly_kwargs or {}),\n    )\n\n    fig = update_figure_layout(fig, title, size, show_scale=show_scale)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/matrix/#blitzly.plots.matrix.pearson_corr_matrix","title":"<code>pearson_corr_matrix(data, title='Pearson correlation matrix', show_scale=False, size=None, decimal_places=4, labels=None, row_var=True, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Creates Pearson product-moment correlation coefficients matrix using NumPy's <code>corrcoef</code> function. Please refer to the NumPy documentation for <code>cov</code> for more detail. The relationship between the correlation coefficient matrix, R, and the covariance matrix, C, is:</p> \\[ R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } } \\] <p>The values of R are between -1 and 1, inclusive.</p> <p>Example: <pre><code>from blitzly.matrix import pearson_corr_matrix\nimport numpy as np\nimport pandas as pd\n\ndata = np.array(\n    [\n        [0.77395605, 0.43887844, 0.85859792],\n        [0.69736803, 0.09417735, 0.97562235],\n        [0.7611397, 0.78606431, 0.12811363],\n    ]\n)\ndf = pd.DataFrame(data, columns=[\"foo\", \"bar\", \"blitzly\"])\npearson_corr_matrix(df, write_html_path=\"the_blitz.html\")\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[pd.DataFrame, NDArray]</code>  <p>The data which should be plotted.</p>  required    <code>title</code>  <code>Optional[str]</code>  <p>The title of the correlation matrix.</p>  <code>'Pearson correlation matrix'</code>    <code>show_scale</code>  <code>Optional[bool]</code>  <p>Whether to show the color scale.</p>  <code>False</code>    <code>decimal_places</code>  <code>Optional[int]</code>  <p>The number of decimal places to round the values to. This only applies to the values shown on the plot.</p>  <code>4</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>labels</code>  <code>Optional[List[str]]</code>  <p>The labels of the columns. If a Pandas DataFrame is passed, the column names will be used.</p>  <code>None</code>    <code>row_var</code>  <code>Optional[bool]</code>  <p>If rowvar is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</p>  <code>True</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments for Plotly.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>      Source code in <code>blitzly/plots/matrix.py</code> <pre><code>def pearson_corr_matrix(\n    data: Union[pd.DataFrame, NDArray],\n    title: str = \"Pearson correlation matrix\",\n    show_scale: bool = False,\n    size: Optional[Tuple[int, int]] = None,\n    decimal_places: int = 4,\n    labels: Optional[List[str]] = None,\n    row_var: bool = True,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"\n    Creates Pearson product-moment correlation coefficients matrix\n    using NumPy's [`corrcoef`](https://numpy.org/doc/stable/reference/generated/numpy.corrcoef.html#numpy-corrcoef) function.\n    Please refer to the NumPy documentation for [`cov`](https://numpy.org/doc/stable/reference/generated/numpy.cov.html#numpy.cov)\n    for more detail. The relationship between the correlation coefficient matrix, R, and the covariance matrix, C, is:\n\n    $$\n    R_{ij} = \\\\frac{ C_{ij} } { \\\\sqrt{ C_{ii} C_{jj} } }\n    $$\n\n    The values of R are between -1 and 1, inclusive.\n\n    Example:\n    ```python\n    from blitzly.matrix import pearson_corr_matrix\n    import numpy as np\n    import pandas as pd\n\n    data = np.array(\n        [\n            [0.77395605, 0.43887844, 0.85859792],\n            [0.69736803, 0.09417735, 0.97562235],\n            [0.7611397, 0.78606431, 0.12811363],\n        ]\n    )\n    df = pd.DataFrame(data, columns=[\"foo\", \"bar\", \"blitzly\"])\n    pearson_corr_matrix(df, write_html_path=\"the_blitz.html\")\n    ```\n\n    Args:\n        data (Union[pd.DataFrame, NDArray]): The data which should be plotted.\n        title (Optional[str]): The title of the correlation matrix.\n        show_scale (Optional[bool]): Whether to show the color scale.\n        decimal_places (Optional[int]): The number of decimal places to round the values to. This only applies to the values shown on the plot.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        labels (Optional[List[str]]): The labels of the columns. If a Pandas DataFrame is passed, the column names will be used.\n        row_var (Optional[bool]): If rowvar is True (default), then each row represents a variable, with observations in the columns.\n            Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments for Plotly.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n    \"\"\"\n\n    if isinstance(data, pd.DataFrame):\n        labels = data.columns\n\n    data = check_data(data, only_square_matrix=True, min_columns=2, min_rows=2)\n\n    correlation = np.corrcoef(data, rowvar=row_var)\n\n    fig = go.Figure(\n        data=go.Heatmap(\n            z=correlation,\n            text=np.round(correlation, decimals=decimal_places),\n            texttemplate=\"%{text}\",\n            x=labels,\n            y=labels,\n        ),\n        **(plotly_kwargs or {}),\n    )\n\n    fig = update_figure_layout(fig, title, size, show_scale=show_scale)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/scatter/","title":"Scatter","text":""},{"location":"plots/scatter/#blitzly.plots.scatter.dimensionality_reduction","title":"<code>dimensionality_reduction(data, reduction_funcs, n_components, target_column, title='Dimensionality reduction plot', scaler_func='StandardScaler', size=None, show_legend=None, reduction_func_kwargs=None, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Create a scatter plot of the dimensionality reduction representation of the data provided. Multiple dimensionality reduction functions can be used. The data is scaled using the <code>scaler_func</code>. If multiple functions are used, the plots are arranged in a grid using.</p> <p><code>make_subplots</code> from blitzly \u26a1\ufe0f.</p> <p>Example: <pre><code>from blitzly.plots.scatter import dimensionality_reduction\nimport plotly.express as px\n\ndf = px.data.iris()\nfig = dimensionality_reduction(\n    df,\n    n_components=2,\n    target_column=\"species\",\n    reduction_funcs=[\"PCA\", \"TNSE\"],\n)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>pd.DataFrame</code>  <p>Data to plot.</p>  required    <code>reduction_funcs</code>  <code>Union[str, List[str]]</code>  <p>Dimensionality reduction function(s) to use. The following functions are supported: NMF, PCA, IncrementalPCA, KernelPCA, MiniBatchSparsePCA, SparsePCA, TruncatedSVD, TSNE.</p>  required    <code>n_components</code>  <code>int</code>  <p>Number of components to use. This parameter is passed to the dimensionality reduction function.</p>  required    <code>target_column</code>  <code>str</code>  <p>Column to use as the color dimension.</p>  required    <code>title</code>  <code>Optional[str]</code>  <p>Title of the plot. Defaults to \"Dimensionality reduction plot\".</p>  <code>'Dimensionality reduction plot'</code>    <code>scaler_func</code>  <code>Optional[str]</code>  <p>Scaler function to use. Defaults to \"StandardScaler\". The following functions are supported: StandardScaler, MinMaxScaler.</p>  <code>'StandardScaler'</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the full plot.</p>  <code>None</code>    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>      Source code in <code>blitzly/plots/scatter.py</code> <pre><code>def dimensionality_reduction(\n    data: pd.DataFrame,\n    reduction_funcs: Union[str, List[str]],\n    n_components: int,\n    target_column: str,\n    title: str = \"Dimensionality reduction plot\",\n    scaler_func: str = \"StandardScaler\",\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: Optional[bool] = None,\n    reduction_func_kwargs: Optional[dict] = None,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Create a scatter plot of the dimensionality reduction representation of\n    the data provided. Multiple dimensionality reduction functions can be used.\n    The data is scaled using the `scaler_func`. If multiple functions are used,\n    the plots are arranged in a grid using.\n\n    [`make_subplots`](https://invia-flights.github.io/blitzly/plots/subplots/#blitzly.subplots.make_subplots) from blitzly \u26a1\ufe0f.\n\n    Example:\n    ```python\n    from blitzly.plots.scatter import dimensionality_reduction\n    import plotly.express as px\n\n    df = px.data.iris()\n    fig = dimensionality_reduction(\n        df,\n        n_components=2,\n        target_column=\"species\",\n        reduction_funcs=[\"PCA\", \"TNSE\"],\n    )\n    ```\n\n    Args:\n        data (pd.DataFrame): Data to plot.\n        reduction_funcs (Union[str, List[str]]): Dimensionality reduction function(s) to use. The following functions are supported:\n            NMF, PCA, IncrementalPCA, KernelPCA, MiniBatchSparsePCA, SparsePCA, TruncatedSVD, TSNE.\n        n_components (int): Number of components to use. This parameter is passed to the dimensionality reduction function.\n        target_column (str): Column to use as the color dimension.\n        title (Optional[str]): Title of the plot. Defaults to \"Dimensionality reduction plot\".\n        scaler_func (Optional[str]): Scaler function to use. Defaults to \"StandardScaler\". The following functions are supported:\n            StandardScaler, MinMaxScaler.\n        size (Optional[Tuple[int, int]): Size of the full plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n    \"\"\"\n\n    func_list = [\n        \"NMF\",\n        \"PCA\",\n        \"IncrementalPCA\",\n        \"KernelPCA\",\n        \"MiniBatchSparsePCA\",\n        \"SparsePCA\",\n        \"TruncatedSVD\",\n        \"TSNE\",\n    ]\n\n    if isinstance(reduction_funcs, str):\n        reduction_funcs = [reduction_funcs]\n\n    if scaler_func not in [\"StandardScaler\", \"MinMaxScaler\"]:\n        raise ValueError(\n            f\"scaler_func must be one of ['StandardScaler', 'MinMaxScaler]! `{scaler_func}` not supported.\"\n        )\n\n    if n_components == 3 and len(reduction_funcs) &gt; 1:\n        raise Warning(\n            \"Cannot plot more than one plot in 3D! Please either set `n_components` to 2 or `reduction_funcs` to one function.\"\n        )\n\n    df = check_data(\n        data, min_rows=1, min_columns=1, as_pandas=True, only_numerical_values=False\n    )\n\n    numerical_df = data.select_dtypes(include=[int, float])\n    scaler = getattr(sk_pre, scaler_func)()\n    numerical_df = scaler.fit_transform(numerical_df)\n\n    plots = []\n    for func in reduction_funcs:\n        if func not in func_list:\n            raise ValueError(\n                f\"reduction_func must be one of {func_list}! `{func}` not supported.\"\n            )\n\n        if func == \"TSNE\":\n            method: Callable = TSNE\n        else:\n            method: Callable = getattr(sk_decomp, func)  # type: ignore\n\n        red_func = method(n_components=n_components, **reduction_func_kwargs or {})\n        projections = red_func.fit_transform(numerical_df)\n\n        if n_components == 2:\n            fig = px.scatter(\n                projections,\n                x=0,\n                y=1,\n                color=df[target_column],\n                labels={\"color\": target_column},\n                **plotly_kwargs or {},\n            )\n        elif n_components == 3:\n            fig = px.scatter_3d(\n                projections,\n                x=0,\n                y=1,\n                z=2,\n                color=df[target_column],\n                labels={\"color\": target_column},\n                **plotly_kwargs or {},\n            )\n        else:\n            raise ValueError(\"`n_components` must be 2 or 3!\")\n\n        plots.append(update_figure_layout(fig, title + f\" ({func})\", size=None))\n\n    len_plots = len(plots)\n    shape = (int(np.ceil(len_plots / 2)), min(len_plots, 2))\n\n    show_legend = show_legend if show_legend and len(plots) == 1 else False\n\n    fig = (\n        make_subplots(\n            plots,\n            shape,\n            size=size,\n            fill_row=True,\n            show_legend=show_legend,\n            show=False,\n        )\n        if n_components == 2\n        else plots[0]\n    )\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/scatter/#blitzly.plots.scatter.multi_scatter","title":"<code>multi_scatter(data, x_y_columns, modes=None, title='Scatter plot', size=None, show_legend=True, plotly_kwargs=None, show=True, write_html_path=None)</code>","text":"<p>Create a multi scatter plot. It can be used to visualize the relationship between multiple variables from the same Pandas DataFrame.</p> <p>Example: <pre><code>from blitzly.plots.scatter import multi_scatter\nimport numpy as np\nimport pandas as pd\n\nrandom_a = np.linspace(0, 1, 100)\nrandom_b = np.random.randn(100) + 5\nrandom_c = np.random.randn(100)\nrandom_d = np.random.randn(100) - 5\ndata = np.array([random_a, random_b, random_c, random_d]).T\n\nmulti_scatter(\n    data=pd.DataFrame(data, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"]),\n    x_y_columns=[(\"foo\", \"bar\"), (\"foo\", \"blitz\"), (\"foo\", \"licht\")],\n    modes=[\"lines\", \"markers\", \"lines+markers\"],\n    plotly_kwargs={\"line\": {\"color\": \"black\"}},\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>pd.DataFrame</code>  <p>Data to plot. Must be a Pandas DataFrame.</p>  required    <code>x_y_columns</code>  <code>List[Tuple[str, str]]</code>  <p>List of tuples containing the x and y columns. Those columns will be used for <code>x</code> and <code>y</code> in the scatter plot. Since it is a multi scatter plot, multiple columns can be used by passing a list of tuples.</p>  required    <code>modes</code>  <code>Optional[List[str]]</code>  <p>List of modes for the scatter plot. If <code>None</code> the <code>\"markers\"</code> mode is used.</p>  <code>None</code>    <code>title</code>  <code>str</code>  <p>Title of the plot.</p>  <code>'Scatter plot'</code>    <code>size</code>  <code>OptionalTuple[int, int]</code>  <p>Size of the plot - height and width.</p>  <code>None</code>    <code>show_legend</code>  <code>bool</code>  <p>Whether to show the legend.</p>  <code>True</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional plotly kwargs.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The multi scatter plot.</p>     Source code in <code>blitzly/plots/scatter.py</code> <pre><code>def multi_scatter(\n    data: pd.DataFrame,\n    x_y_columns: List[Tuple[str, str]],\n    modes: Optional[List[str]] = None,\n    title: str = \"Scatter plot\",\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: bool = True,\n    plotly_kwargs: Optional[dict] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Create a multi scatter plot. It can be used to visualize the\n    relationship between multiple variables from the same Pandas DataFrame.\n\n    Example:\n    ```python\n    from blitzly.plots.scatter import multi_scatter\n    import numpy as np\n    import pandas as pd\n\n    random_a = np.linspace(0, 1, 100)\n    random_b = np.random.randn(100) + 5\n    random_c = np.random.randn(100)\n    random_d = np.random.randn(100) - 5\n    data = np.array([random_a, random_b, random_c, random_d]).T\n\n    multi_scatter(\n        data=pd.DataFrame(data, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"]),\n        x_y_columns=[(\"foo\", \"bar\"), (\"foo\", \"blitz\"), (\"foo\", \"licht\")],\n        modes=[\"lines\", \"markers\", \"lines+markers\"],\n        plotly_kwargs={\"line\": {\"color\": \"black\"}},\n    ```\n\n    Args:\n        data (pd.DataFrame): Data to plot. Must be a Pandas DataFrame.\n        x_y_columns (List[Tuple[str, str]]): List of tuples containing the x and y columns.\n            Those columns will be used for `x` and `y` in the scatter plot.\n            Since it is a multi scatter plot, multiple columns can be used by passing a list of tuples.\n        modes (Optional[List[str]]): List of modes for the scatter plot. If `None` the `\"markers\"` mode is used.\n        title (str): Title of the plot.\n        size (OptionalTuple[int, int]): Size of the plot - height and width.\n        show_legend (bool): Whether to show the legend.\n        plotly_kwargs (Optional[dict]): Additional plotly kwargs.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n\n    Returns:\n        BaseFigure: The multi scatter plot.\n    \"\"\"\n\n    df = check_data(data, min_rows=1, min_columns=1, as_pandas=True)\n\n    if len([i for i in list(sum(x_y_columns, ())) if i not in df.columns]) &gt; 0:\n        raise ValueError(\n            f\"\"\"\n            Columns {list(set(list(sum(x_y_columns, ()))) - set(df.columns))} not in `data`!\n            All columns passed in `x_y_columns` must be in `data`.\n            \"\"\"\n        )\n\n    if modes and len(modes) != len(x_y_columns):\n        raise ValueError(\n            f\"\"\"\n            Length of `modes` ({len(modes)}) must be equal to length of `x_y_columns` ({len(x_y_columns)})!\n            Or `modes` must be `None`.\n            \"\"\"\n        )\n\n    fig = go.Figure()\n    for idx, item in enumerate(x_y_columns):\n        fig.add_trace(\n            go.Scatter(\n                x=df[item[0]],\n                y=df[item[1]],\n                mode=modes[idx] if modes else \"markers\",\n                name=list(df.columns)[idx],\n                **plotly_kwargs or {},\n            )\n        )\n\n    fig = update_figure_layout(fig, title, size, show_legend)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/scatter/#blitzly.plots.scatter.scatter_matrix","title":"<code>scatter_matrix(data, dimensions=None, color_dim=None, show_upper_half=False, diagonal_visible=False, show_scale=False, title='Scatter matrix', marker_line_color='white', marker_line_width=0.5, marker_color_scale='Plasma', size=None, show_legend=False, show=True, write_html_path=None)</code>","text":"<p>Create a scatter matrix plot. It can be used to visualize the relationship between multiple variables. The scatter matrix is a grid of scatter plots, one for each pair of variables in the data. The diagonal plots are histograms of the corresponding variables. It is also useful for visualizing the distribution of each variable.</p> <p>Example: <pre><code>from blitzly.plots.scatter import scatter_matrix\nimport numpy as np\nimport pandas as pd\n\nfoo = np.random.randn(1000)\nbar = np.random.randn(1000) + 1\nblitz = np.random.randint(2, size=1000)\nlicht = np.random.randint(2, size=1000)\ndata = np.array([foo, bar, blitz, licht])\ndf = pd.DataFrame(data.T, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"])\n\nscatter_matrix(\n    df,\n    dimensions=[\"foo\", \"bar\", \"blitz\"],\n    color_dim=df[\"licht\"],\n    title=\"My first scatter matrix \ud83d\ude43\",\n    show_upper_half=True,\n    diagonal_visible=False,\n    marker_color_scale=\"Rainbow\",\n    marker_line_color=\"blue\",\n    size=(500, 500),\n)\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>pd.DataFrame</code>  <p>Data to plot.</p>  required    <code>dimensions</code>  <code>Optional[List[str]]</code>  <p>List of columns to plot. If <code>None</code> all columns from the Pandas DataFrame are used.</p>  <code>None</code>    <code>color_dim</code>  <code>Optional[Union[pd.Series, List[str], NDArray]]</code>  <p>Color dimension. If <code>None</code> no color is used.</p>  <code>None</code>    <code>show_upper_half</code>  <code>bool</code>  <p>Show upper half of the scatter matrix.</p>  <code>False</code>    <code>diagonal_visible</code>  <code>bool</code>  <p>Show diagonal part of the matrix.</p>  <code>False</code>    <code>show_scale</code>  <code>bool</code>  <p>Show color scale.</p>  <code>False</code>    <code>title</code>  <code>str</code>  <p>Title of the plot.</p>  <code>'Scatter matrix'</code>    <code>marker_line_color</code>  <code>str</code>  <p>Color of the marker line.</p>  <code>'white'</code>    <code>marker_line_width</code>  <code>float</code>  <p>Width of the marker line.</p>  <code>0.5</code>    <code>marker_color_scale</code>  <code>str</code>  <p>Color scale of the markers.</p>  <code>'Plasma'</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>show_legend</code>  <code>Optional[bool]</code>  <p>Whether to show the legend.</p>  <code>False</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The scatter matrix plot.</p>     Source code in <code>blitzly/plots/scatter.py</code> <pre><code>def scatter_matrix(\n    data: pd.DataFrame,\n    dimensions: Optional[List[str]] = None,\n    color_dim: Optional[Union[pd.Series, List[str], NDArray]] = None,\n    show_upper_half: bool = False,\n    diagonal_visible: bool = False,\n    show_scale: bool = False,\n    title: str = \"Scatter matrix\",\n    marker_line_color: str = \"white\",\n    marker_line_width: float = 0.5,\n    marker_color_scale: str = \"Plasma\",\n    size: Optional[Tuple[int, int]] = None,\n    show_legend: Optional[bool] = False,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Create a scatter matrix plot. It can be used to visualize the\n    relationship between multiple variables. The scatter matrix is a grid of\n    scatter plots, one for each pair of variables in the data. The diagonal\n    plots are histograms of the corresponding variables. It is also useful for\n    visualizing the distribution of each variable.\n\n    Example:\n    ```python\n    from blitzly.plots.scatter import scatter_matrix\n    import numpy as np\n    import pandas as pd\n\n    foo = np.random.randn(1000)\n    bar = np.random.randn(1000) + 1\n    blitz = np.random.randint(2, size=1000)\n    licht = np.random.randint(2, size=1000)\n    data = np.array([foo, bar, blitz, licht])\n    df = pd.DataFrame(data.T, columns=[\"foo\", \"bar\", \"blitz\", \"licht\"])\n\n    scatter_matrix(\n        df,\n        dimensions=[\"foo\", \"bar\", \"blitz\"],\n        color_dim=df[\"licht\"],\n        title=\"My first scatter matrix \ud83d\ude43\",\n        show_upper_half=True,\n        diagonal_visible=False,\n        marker_color_scale=\"Rainbow\",\n        marker_line_color=\"blue\",\n        size=(500, 500),\n    )\n    ```\n\n    Args:\n        data (pd.DataFrame): Data to plot.\n        dimensions (Optional[List[str]], optional): List of columns to plot. If `None` all columns from the Pandas DataFrame are used.\n        color_dim (Optional[Union[pd.Series, List[str], NDArray]]): Color dimension. If `None` no color is used.\n        show_upper_half (bool): Show upper half of the scatter matrix.\n        diagonal_visible (bool): Show diagonal part of the matrix.\n        show_scale (bool): Show color scale.\n        title (str): Title of the plot.\n        marker_line_color (str): Color of the marker line.\n        marker_line_width (float): Width of the marker line.\n        marker_color_scale (str): Color scale of the markers.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        show_legend (Optional[bool]): Whether to show the legend.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The scatter matrix plot.\n    \"\"\"\n\n    if isinstance(color_dim, np.ndarray) and color_dim.ndim != 1:\n        raise ValueError(\"`color_dim` must be a 1-dimensional array!\")\n\n    if dimensions is None:\n        dimensions = list(data.columns)\n\n    dims = [dict(label=dim, values=data[dim]) for dim in dimensions]\n\n    _ = check_data(data, min_rows=2, min_columns=2)\n\n    fig = go.Figure(\n        data=go.Splom(\n            dimensions=dims,\n            showupperhalf=show_upper_half,\n            marker=dict(\n                colorscale=marker_color_scale,\n                color=color_dim,\n                showscale=show_scale,\n                line_color=marker_line_color,\n                line_width=marker_line_width,\n            ),\n            diagonal=dict(visible=diagonal_visible),\n        )\n    )\n\n    fig = update_figure_layout(fig, title, size, show_legend)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"},{"location":"plots/subplots/","title":"Subplots","text":""},{"location":"plots/subplots/#blitzly.subplots.make_subplots","title":"<code>make_subplots(subfig_list, shape, title=None, column_widths=None, fill_row=False, shared_xaxes=False, shared_yaxes=False, plotly_kwargs=None, show_legend=False, size=None, show=True, write_html_path=None)</code>","text":"<p>Creates subplots using a provided list of figure objects. <code>plotly.subplots.make_subplots</code> requires the use of traces. This function is an alternative implementation that directly uses previously-created figure objects.</p> <p>Example: <pre><code>from blitzly.subplots import make_subplots\nfrom blitzly.plots.histogram import simple_histogram\nimport numpy as np\n\nfig1 = simple_histogram(np.random.randn(100), show=False)\nfig2 = simple_histogram(np.random.randn(100), show=False)\n\nmake_subplots([fig1, fig2], (1, 2))\n</code></pre></p> <p>Parameters:</p>    Name Type Description Default     <code>subfig_list</code>  <code>List[BaseFigure]</code>  <p>A list of figure objects.</p>  required    <code>shape</code>  <code>Tuple[int, int]</code>  <p>The grid shape of the subplots.</p>  required    <code>title</code>  <code>str</code>  <p>Title of the plot.</p>  <code>None</code>    <code>column_widths</code>  <code>Optional[List[float]]</code>  <p>The width of each column in the subplot grid.</p>  <code>None</code>    <code>fill_row</code>  <code>bool</code>  <p>If True, resize the last subplot in the grid to fill the row.</p>  <code>False</code>    <code>shared_xaxes</code>  <code>bool</code>  <p>Share the x-axis labels along each column.</p>  <code>False</code>    <code>shared_yaxes</code>  <code>bool</code>  <p>Share the y-axis labels along each row.</p>  <code>False</code>    <code>plotly_kwargs</code>  <code>Optional[dict]</code>  <p>Additional keyword arguments to pass to Plotly <code>subplots.make_subplots</code>.</p>  <code>None</code>    <code>show_legend</code>  <code>bool</code>  <p>Whether to show the legend.</p>  <code>False</code>    <code>size</code>  <code>Optional[Tuple[int, int]</code>  <p>Size of the plot.</p>  <code>None</code>    <code>show</code>  <code>bool</code>  <p>Whether to show the figure.</p>  <code>True</code>    <code>write_html_path</code>  <code>Optional[str]</code>  <p>The path to which the histogram should be written as an HTML file. If None, the histogram will not be saved.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>BaseFigure</code>  <code>BaseFigure</code>  <p>The provided list figures as subplots in a single figure object.</p>     Source code in <code>blitzly/subplots.py</code> <pre><code>def make_subplots(\n    subfig_list: List[BaseFigure],\n    shape: Tuple[int, int],\n    title: Optional[str] = None,\n    column_widths: Optional[List[float]] = None,\n    fill_row: bool = False,\n    shared_xaxes: bool = False,\n    shared_yaxes: bool = False,\n    plotly_kwargs: Optional[dict] = None,\n    show_legend: bool = False,\n    size: Optional[Tuple[int, int]] = None,\n    show: bool = True,\n    write_html_path: Optional[str] = None,\n) -&gt; BaseFigure:\n    \"\"\"Creates subplots using a provided list of figure objects.\n    `plotly.subplots.make_subplots` requires the use of traces. This function\n    is an alternative implementation that directly uses previously-created\n    figure objects.\n\n    Example:\n    ```python\n    from blitzly.subplots import make_subplots\n    from blitzly.plots.histogram import simple_histogram\n    import numpy as np\n\n    fig1 = simple_histogram(np.random.randn(100), show=False)\n    fig2 = simple_histogram(np.random.randn(100), show=False)\n\n    make_subplots([fig1, fig2], (1, 2))\n    ```\n\n    Args:\n        subfig_list (List[BaseFigure]): A list of figure objects.\n        shape (Tuple[int, int]): The grid shape of the subplots.\n        title (str): Title of the plot.\n        column_widths (Optional[List[float]]): The width of each column in the subplot grid.\n        fill_row (bool): If True, resize the last subplot in the grid to fill the row.\n        shared_xaxes (bool): Share the x-axis labels along each column.\n        shared_yaxes (bool): Share the y-axis labels along each row.\n        plotly_kwargs (Optional[dict]): Additional keyword arguments to pass to Plotly `subplots.make_subplots`.\n        show_legend (bool): Whether to show the legend.\n        size (Optional[Tuple[int, int]): Size of the plot.\n        show (bool): Whether to show the figure.\n        write_html_path (Optional[str]): The path to which the histogram should be written as an HTML file.\n            If None, the histogram will not be saved.\n\n    Returns:\n        BaseFigure: The provided list figures as subplots in a single figure object.\n    \"\"\"\n\n    _check_shape_for_subplots(subfig_list, shape)\n\n    subfig_traces: List[List[BaseTraceType]] = [[] for _ in subfig_list]\n\n    for idx, subfig in enumerate(subfig_list):\n        for trace in range(len(subfig[\"data\"])):\n            subfig_traces[idx].append(subfig[\"data\"][trace])\n\n    subplot_titles = [subfig.layout.title.text for subfig in subfig_list]\n\n    subplot_axes_labels = [\n        [subfig.layout.xaxis.title.text for subfig in subfig_list],\n        [subfig.layout.yaxis.title.text for subfig in subfig_list],\n    ]\n\n    specs: List[List[dict]] = [[{} for _ in range(shape[1])] for _ in range(shape[0])]\n    n_missing_slots = int(np.prod(shape) - len(subfig_list))\n    if n_missing_slots in range(1, shape[1]) and fill_row:\n        specs[-1][-1 - n_missing_slots][\"colspan\"] = 1 + n_missing_slots\n\n    fig = sp.make_subplots(\n        rows=shape[0],\n        cols=shape[1],\n        subplot_titles=subplot_titles,\n        column_widths=column_widths,\n        specs=specs,\n        shared_xaxes=shared_xaxes,\n        shared_yaxes=shared_yaxes,\n        **plotly_kwargs if plotly_kwargs else {},\n    )\n\n    for idx, traces in enumerate(subfig_traces):\n        row = idx // shape[1]\n        col = idx % shape[1]\n        for trace in traces:\n            fig.add_trace(trace, row=row + 1, col=col + 1)\n\n        if row != shape[0] - 1 and shared_xaxes:\n            subplot_axes_labels[0][idx] = \"\"\n        if col != 0 and shared_yaxes:\n            subplot_axes_labels[1][idx] = \"\"\n        fig.update_xaxes(\n            title_text=subplot_axes_labels[0][idx], row=row + 1, col=col + 1\n        )\n        fig.update_yaxes(\n            title_text=subplot_axes_labels[1][idx], row=row + 1, col=col + 1\n        )\n\n    fig.update_layout(showlegend=show_legend)\n    fig = update_figure_layout(fig, title, size)\n    return save_show_return(fig, write_html_path, show)\n</code></pre>"}]}